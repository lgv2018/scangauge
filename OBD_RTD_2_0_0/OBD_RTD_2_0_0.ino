/**
 * ALEX NEIMAN'S Neiman Mfg. Co (Neimdawg Industries) Real time diagnostics OBD Scan gauge tool.
 * 
 *      
 *      
 *      Z8L NNNN';NNNs qNNN.!NNNa SNNN,~NNNq INNN;'NNNA LNNN>`NNNR TNNNT RNNN`>NNNf ANNN';Nq 
 *    :@@^ ||||`'|||; =|||`'|||! !|||..|||+ ;|||'`|||+ ~|||, |||* ~|||~ *||| ,|||; +|||`a@Q 
 *    _!;                                                                               !!, 
 *    @@Y    !ii+    ,ii;  Liiiiii^ `ii|  `iiL      ;ii<      *ii=     .iiL`   `|ii    +@@' 
 *   'XD,    Q@@@J   X@@< ;@@@%%%%? |@@A  L@@@|    J@@@U     k@@@@.    7@@@R`  +@@B    ?Kw  
 *   IE?    !@@@@@j `@@@` h@@S      g@@^  Q@@@@` `D@@@@|   `%@Q<@@Y    Q@@@@N` d@@c   `6a,  
 *  `@@|    6@@jq@@wL@@m `@@@@@@@J ,@@Q  *@@b@@o~Q@%@@@'  ,Q@Q' Q@Q.  ~@@QL@@Q~@@@`   \@@`  
 *  '!^`   `@@@, K@@@@@; <@@Q,,,,` t@@5 `B@@'X@@@@o~@@Q  _Q@@BKK@@@z  y@@z i@@@@@d    ~!;   
 *  W@X    |@@k   k@@@Q  D@@#jjj{  Q@@_ c@@w 'EEE+ 7@@S ^@@Qiiiij@@Q  @@@.  <@@@@+   ,@@;   
 * `%Q!    |yy,    7yy+  yyyyyyyi .yyn  7yy'       ?yy~'yyy.     yyy''yy7    !yyy    >NN    
 * ^7^                                                                               zi,    
 *`Q@q` :::, .:::. ,::: .:::' ,::: `:::' ':::``:::' ':::` :::, ':::. :::: .:::` ,:::!@@,    
 *,Q@@L`@@@Q }@@@} Q@@@`i@@@w N@@@'^@@@a 6@@@;~@@@K K@@@='@@@N Z@@@T @@@@ J@@@L`Q@@@~aU
 *
 *
 * 
 * 
 * **********DISCLAIMER******
 * YOU ARE OPENING A SERIOUS CAN OF WORMS HERE...
 * messing around with your vehicle/can bus can cause damage and/or unintentional operation of your
 * vehicle! I am providing this code and instruction to you with no warranty or guarantee.
 * You assume all risk. Try this while the vehicle is PARKED FIRST! This project is actually
 * fairly safe if you simply do a little research about what you are doing. If you don't know what
 * any part of the instructions or code means, it's probably a sign that you should not be messing 
 * with your car's electrical system! Don't take this project on. Buy a premade bluetooth OBD
 * dongle and use that instead.
 * 
 * I wish you good luck...
 * **************************
 * 
 * This uses the CAN bus interface to send requests to the ECU using OBD protocol.
 * Currently configured for TOYOTA Prius 2020. 
 * 
 * Works like this: Arduino sends out a msg on the CAN bus with a CAN ID of D0x7DF.
 * That means "request". Encoded in that message is your PID that you are requesting.
 * Look at function called requestDataOBD(). See the third byte set to var pid? That's the
 * PID you are asking for. The ecu will then send a return message on the CAN bus with an ID
 * of 0x7eA with your requested PID encoded. That is what the Arduino is listening for! 
 * 
 * Each PID corresponds to a different measurement. Look at the #define starting w/ PID to see
 * some various different values that can be requested from the ecu. If you're getting wrong/no
 * data, try changing the PID that you are requesting. To find PIDs for your vehicle, you can
 * visit : (for Prius and some Subaru) (switch to appropriate tab on sheet for your subi/toy)
 * https://docs.google.com/spreadsheets/d/1QYWdWkLg0O4tg-ANYdTwwEMhpjkYAI_5JpBfTR1JfQ0/edit?hl=en&hl=en#gid=6
 * and (wikipedia, general codes for most vehicles)
 * https://en.wikipedia.org/wiki/OBD-II_PIDs#Service_01
 * to find some other pid values. Keep in mind that you must adjust the draw functions for
 * size/position so that the values fit on the screen. The defaults are RPM and engine temp.
 * 
 * PINOUT for Arduino NANO:
 * can-
 *    13 SCk
 *    11 MOSI
 *    12 MISO
 *    10 CS
 * oled-
 *    A4 SCL
 *    A5 SDA
 * and of course vcc and gnd for each board.
 * 
 * OLED not showing up? First upload an I2c scanner sketch. Google it if you need the code. If it
 * shows up on the scanner, make sure your i2c addres in THIS sketch has been changed to match the
 * address of your oled. That could be the issue!
 * 
 * Hook the CAN Hi and Lo up to the CAN bus of your car. Next, hook the GND into the vehicle. 
 * There are signal gnd and chassis gnd in the obd port by default. I used both of those as
 * ground. Next, you need to apply power to system. I used a fuse tap on the windshield wiper circuit
 * since my prius has many circuits fused in a box right next to OBD port. You can use
 * the Vbatt on the OBD port, but beware! That is hooked to the battery, so the device will never
 * turn off. Depending on the current draw of the arduino, it may kill your battery in a matter 
 * of days or weeks if you let your car sit! You may have a vehicle with an ACC/ignition power pin
 * on the OBD port. Lots of pins are manufacturer specific. However, don't just try the multimeter 
 * and hook your arduino up to anything with 12 volts! Your vehicle may have a J1699 or other serial
 * bus that uses 12v logic level. Who knows what a current draw would do! Check with oscilliscope 
 * to make sure your "12volt source" is a steady DC power supply, not a signal, before you hook
 * arduino power to any other pin besides batt on the OBD port.
 * 
 * Once you hook everything up, run a wire up the steering column (or even thru the dash)
 * for your OLED. Mind knee curtain airbags! Parking brake. gas and brake pedal...don't be stupid.
 * Don't run the wire in front of anything important.
 * 
 * I have 3d printable housing designs. one for the microcontroller and one for the oled. It is nicely
 * sloped so that the screen is perfectly angled with my dashboard above the steering wheel. Try
 * designing your own for a custom place in your vehicle!
 * 
 * NOTE ON OPERATION:
 * The device will poll for RPM data every 1,430 ms. It will poll for engine temp every 9,930 ms.
 * I chose these values so that there is a low chance of two signals being sent within a short time
 * of each other. I have found that the CAN bus transciever has a hard time reporting multiple responses
 * when multiple CAN bus frames are recieved at one time. The important takeaway is this: the engine
 * temp only updates at roughly ten second intervals. When  you turn the device on, there will be
 * no data for temp. I set the default value for temp to be 999. If the arduino sees this value, it
 * will not be drawn. However, the RPM updates once a second. By the time the welcome screen has
 * dissapeared, the 1430ms period has elapsed, and the arduino will immediately request engine RPM.
 * 
 * My point is this: if you turn your car on and see 9999 RPMs, something is wrong! That means that
 * the arduino is not communicating with your vehicle. You should see engine temp come on the screen
 * after about ten seconds.
 * 
 * 
 */

// libraries
#include <SPI.h>
#include <mcp2515.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// misc placeholders
#define log_all_codes false
#define PID_RPM 0x0C
#define PID_OutsideTemp 0x46
#define PID_FuelTank 0x2F
#define PID_EngineLoad 0x04
#define PID_CoolantTemp 0x05
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define OLED_RESET     4 // not sure what this is hahahaha
#define init_delay 3000 // duration that the startup screen is displayed.

// vanity placeholders
#define DEVICE_SERIAL_NUMBER "G0101"
#define DEVICE_NAME "OBD Scan Gauge Device"
#define HARDWARE_VERSION "Hw2.0"
#define DATE_OF_MFG "11/01/2020"
#define FIRMWARE_VERSION "2.0"
#define FIRMWARE_BUILD  "01"

// frame structures
struct can_frame canMsg;
struct can_frame canMsgOutgoing;

// create objects/init board
MCP2515 mcp2515(10);
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// timer vars
// max value of an unsigned long is ~2^32...this arduino will run for 50 days and then
// who knows what will happen when the millis() exceeds the max!
unsigned long last_rpm = 0;
unsigned long last_temp = 0;

// display coordinate calculation vars
int16_t xs1, ys1;
uint16_t w, h;

// data vars
int rpm = 9999;
int eng_temp = 999;
int incoming_byte_serial[11];

// startup logo. says NEIMAN real time diagnostics. Replace it with your own!
/*
// old logo (text only)
const unsigned char bitmap [] PROGMEM={
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x80, 0x00, 0x40, 0x00, 0x00, 0x0c, 0x00, 0x20, 0x00, 0x00, 0x60, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x80, 0x00, 0x40, 0x00, 0x00, 0x0c, 0x00, 0x20, 0x00, 0x60, 0x20, 0x00, 0x00, 
  0x00, 0x04, 0x10, 0x04, 0xc3, 0xc6, 0x00, 0x08, 0x00, 0x21, 0xe0, 0x0c, 0x61, 0x03, 0x0c, 0x00, 
  0x00, 0x3e, 0x7d, 0xbf, 0xe7, 0xdf, 0x64, 0xdf, 0x0d, 0xf3, 0xec, 0xdf, 0x77, 0xe7, 0x9e, 0x00, 
  0x00, 0x33, 0x4d, 0xb3, 0x26, 0xc1, 0x6e, 0xf3, 0x0d, 0x9b, 0x6c, 0xd8, 0x66, 0x6c, 0xf0, 0x00, 
  0x00, 0x33, 0x7d, 0xb3, 0x26, 0x4f, 0x2e, 0xb3, 0x0d, 0x9b, 0x2c, 0xdf, 0x64, 0x6f, 0xde, 0x00, 
  0x00, 0x33, 0x61, 0xb3, 0x26, 0x5b, 0x3b, 0xb3, 0x0d, 0x9b, 0x2c, 0xc7, 0x64, 0x6c, 0x0f, 0x00, 
  0x00, 0x33, 0x69, 0xb3, 0x26, 0xfb, 0x3b, 0x9f, 0x0d, 0x9b, 0x6f, 0xdb, 0x64, 0x6e, 0xb3, 0x00, 
  0x00, 0x33, 0x3d, 0xb3, 0x23, 0xdf, 0x1b, 0x1f, 0x0d, 0x99, 0xe7, 0xdf, 0x34, 0x67, 0x9e, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x3c, 0xe1, 0x10, 0x3e, 0xc8, 0x4e, 0x0f, 0x30, 0x87, 0x22, 0x38, 0xef, 0xb1, 0x8e, 0x00, 
  0x00, 0x24, 0x83, 0x10, 0x08, 0x4c, 0xc8, 0x08, 0x11, 0x88, 0x32, 0x45, 0x02, 0x12, 0x08, 0x00, 
  0x00, 0x24, 0x82, 0x90, 0x08, 0x4b, 0x48, 0x08, 0x91, 0x48, 0x3a, 0x45, 0x82, 0x12, 0x08, 0x00, 
  0x00, 0x38, 0xe3, 0x90, 0x08, 0x4b, 0x4e, 0x08, 0x91, 0xc9, 0xaa, 0x44, 0x62, 0x12, 0x02, 0x00, 
  0x00, 0x28, 0x84, 0x90, 0x08, 0x48, 0x48, 0x08, 0x92, 0x48, 0xa6, 0x44, 0x22, 0x12, 0x01, 0x00, 
  0x00, 0x24, 0xe4, 0x5c, 0x08, 0xc8, 0x4e, 0x0f, 0x32, 0x27, 0xa2, 0x38, 0xe2, 0x31, 0xce, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };*/

 // 'OBD Logo 2 copy', 128x32px ALTERNATE Startup logo (second iteration)
const unsigned char bitmap [] PROGMEM = {
 0x55, 0x45, 0x55, 0x09, 0x22, 0xaa, 0xaa, 0xb6, 0xb7, 0xbd, 0x6a, 0xab, 0x7f, 0xed, 0xef, 0xf7, 
  0x00, 0x10, 0x22, 0xb2, 0xad, 0x55, 0x55, 0x6d, 0x6a, 0xd7, 0xbf, 0xfd, 0xf6, 0xff, 0xff, 0xff, 
  0x2a, 0xa5, 0x44, 0x44, 0x51, 0x2a, 0xaa, 0xca, 0xdd, 0xad, 0x55, 0x57, 0xaf, 0xb7, 0xbb, 0x7f, 
  0x40, 0x08, 0x09, 0x21, 0x00, 0x00, 0x10, 0x35, 0x06, 0xd0, 0xf8, 0x3d, 0x43, 0xfd, 0xff, 0xff, 
  0x15, 0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x20, 0x06, 0x00, 0xc0, 0x3f, 0xff, 
  0x40, 0x10, 0x00, 0x80, 0x00, 0x00, 0x00, 0x08, 0x00, 0x80, 0x10, 0x02, 0x00, 0x80, 0x17, 0xef, 
  0x0a, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x0e, 0xff, 
  0x50, 0x08, 0xf0, 0x0e, 0x7f, 0xfd, 0xcf, 0x80, 0xf8, 0x1e, 0x03, 0xc0, 0x78, 0x1f, 0x8f, 0xff, 
  0x05, 0x40, 0xf8, 0x1e, 0xff, 0xfd, 0xcf, 0xc1, 0xf8, 0x3f, 0x03, 0xe0, 0x78, 0x3f, 0xcf, 0xff, 
  0x50, 0x11, 0xf8, 0x1e, 0xff, 0xff, 0xdf, 0xc1, 0xf8, 0x3f, 0x07, 0xe0, 0x78, 0x70, 0xc7, 0xbf, 
  0x02, 0xa1, 0xfc, 0x1e, 0xff, 0xfb, 0xdf, 0xc3, 0xf8, 0x7f, 0x07, 0xe0, 0x78, 0x60, 0xc7, 0xef, 
  0x54, 0x01, 0xfc, 0x1e, 0xf0, 0x03, 0xdf, 0xc7, 0xf8, 0x7f, 0x07, 0xf0, 0xf8, 0x63, 0x8f, 0xff, 
  0x02, 0xa1, 0xfe, 0x3f, 0xf0, 0x03, 0xdf, 0xc7, 0xf8, 0xf7, 0x87, 0xf0, 0xf0, 0x7f, 0x8e, 0xff, 
  0x28, 0x01, 0xfe, 0x3d, 0xe0, 0x07, 0xdf, 0xc7, 0xf0, 0xf7, 0x8f, 0xf8, 0xf0, 0x7f, 0x8f, 0xff, 
  0x42, 0xa3, 0xfe, 0x3d, 0xff, 0xf7, 0xff, 0xcf, 0xf1, 0xe7, 0x8f, 0xf8, 0xf0, 0xc0, 0x1f, 0xff, 
  0x14, 0x03, 0xdf, 0x3d, 0xff, 0xf7, 0xbd, 0xcf, 0xf3, 0xe7, 0xcf, 0x7c, 0xf0, 0xc0, 0x3f, 0xff, 
  0x41, 0x43, 0xcf, 0x3d, 0xff, 0xf7, 0xbd, 0xde, 0xf3, 0xc7, 0xcf, 0x3c, 0xf0, 0xff, 0x1d, 0xdf, 
  0x14, 0x03, 0xcf, 0xbf, 0xff, 0xe7, 0xbd, 0xde, 0xf7, 0xc3, 0xcf, 0x3e, 0xe0, 0xff, 0x1f, 0xff, 
  0x21, 0x43, 0xc7, 0xfb, 0xc0, 0x0f, 0xb9, 0xfd, 0xf7, 0xff, 0xdf, 0x3f, 0xe1, 0xc0, 0x1f, 0xff, 
  0x4a, 0x07, 0xc7, 0xfb, 0xc0, 0x0f, 0xf9, 0xfd, 0xef, 0xff, 0xde, 0x1f, 0xe1, 0x80, 0x3f, 0xff, 
  0x01, 0x07, 0x87, 0xfb, 0xc0, 0x0f, 0x79, 0xf9, 0xef, 0xff, 0xde, 0x1f, 0xe0, 0xe6, 0x37, 0x7f, 
  0x54, 0x47, 0x83, 0xfb, 0xc0, 0x0f, 0x79, 0xf9, 0xfe, 0x03, 0xfe, 0x0f, 0xe1, 0xfe, 0x3f, 0xff, 
  0x00, 0x87, 0x81, 0xff, 0xff, 0xef, 0x79, 0xf9, 0xfe, 0x03, 0xfe, 0x0f, 0xc1, 0xbc, 0x3f, 0xff, 
  0x55, 0x07, 0x81, 0xf7, 0xff, 0xff, 0x79, 0xf1, 0xfc, 0x01, 0xfe, 0x07, 0xc3, 0x30, 0x7f, 0xff, 
  0x00, 0x87, 0x01, 0xf3, 0xff, 0xee, 0x71, 0xf1, 0xfc, 0x01, 0xfc, 0x07, 0xc3, 0xf0, 0x77, 0xef, 
  0xaa, 0x03, 0x00, 0xe1, 0xff, 0xce, 0x70, 0xe1, 0xd8, 0x30, 0xdc, 0x03, 0x83, 0xfc, 0x3e, 0xff, 
  0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x20, 0x03, 0xfc, 0x7f, 0xff, 
  0x55, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x00, 0xc0, 0x00, 0x00, 0xff, 0xff, 
  0x00, 0xa0, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x78, 0x00, 0xf0, 0x18, 0x00, 0xff, 0xff, 
  0x55, 0x09, 0x42, 0x95, 0x4a, 0xa9, 0x55, 0x5d, 0x57, 0xae, 0xb7, 0x5d, 0x7e, 0xab, 0xfb, 0xff, 
  0x00, 0x52, 0x2d, 0x2a, 0x55, 0x56, 0xaa, 0xab, 0x6d, 0x7b, 0xed, 0xf7, 0xd7, 0xff, 0xdf, 0x7f, 
  0x55, 0x24, 0x90, 0xa5, 0xaa, 0xa9, 0x55, 0x75, 0xb6, 0xd6, 0xbb, 0x7d, 0xff, 0xff, 0xff, 0xff
};


// icons. Rpm on left, temp on right.
const unsigned char icons [] PROGMEM = {
  0x43, 0xe0, 0x22, 0x00, 0x86, 0xb0, 0x53, 0x00, 0x48, 0x28, 0x02, 0x00, 0x18, 0x4c, 0x03, 0x00, 
  0x10, 0x44, 0x02, 0x00, 0x18, 0x8c, 0x07, 0x00, 0x10, 0x04, 0x97, 0x48, 0x18, 0x0c, 0x67, 0x30, 
  0x08, 0x08, 0x00, 0x00, 0x06, 0x30, 0x92, 0x48, 0x03, 0xe0, 0x6d, 0xb0
};

// function to request OBD data
void requestDataOBD(unsigned long int pid) {
  canMsgOutgoing.can_id  = 0x7DF;   // request
  canMsgOutgoing.can_dlc = 8;       // length of data frame
  canMsgOutgoing.data[0] = 0x02;    // ?
  canMsgOutgoing.data[1] = 0x01;    // ?
  canMsgOutgoing.data[2] = pid;    // OBD PID that we are requesting
  canMsgOutgoing.data[3] = 0x00;   // zeros
  canMsgOutgoing.data[4] = 0x00;
  canMsgOutgoing.data[5] = 0x00;
  canMsgOutgoing.data[6] = 0x00;
  canMsgOutgoing.data[7] = 0x00;
  mcp2515.sendMessage(&canMsgOutgoing);
}


// display rpm and temp: setup
void drawRpmSetup() {
  // prepare graphics
  display.clearDisplay();

  //int16_t x1, y1;
  //uint16_t w, h;

  // rpm number
  display.setTextSize(4);
  display.setTextColor(SSD1306_WHITE);
  display.getTextBounds(String(rpm), 0, 0, &xs1, &ys1, &w, &h);
  display.setCursor(96-w,0);
  display.cp437(true);
  display.print(rpm);



  // engine temp
  display.setTextSize(2);
  display.getTextBounds(String(eng_temp), 0, 0, &xs1, &ys1, &w, &h);
  display.setTextWrap(false);
  display.setCursor(130-w,0);
  if (eng_temp != 999) {
    display.print(eng_temp);
  }


  // icons label
  display.drawBitmap(98,16,icons,29,11,1);

  // display changes
  display.display();
}

 void setup() {
  // init screen
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32. Note: if your display does
    for(;;); //                                       not work, try an i2c scanner to find the correct addy.
  }
  display.clearDisplay();
  display.drawBitmap(0, 0, bitmap, 128, 32, 1);
  display.display();

  // init can board
  mcp2515.reset();
  mcp2515.setBitrate(CAN_1000KBPS); // Your vehicle may use a different speed!
  mcp2515.setNormalMode();

  // wait for a second
  delay(500);
  delay(init_delay);

  drawRpmSetup();
}

void loop() {
  // "queue" data update requests
  if ((millis() - last_rpm) > 1430) { // change these values here to change the update frequency
    requestDataOBD(PID_RPM);
    // update counter
    last_rpm = millis();
  }
  if ((millis() - last_temp) > 9930) { // this one too
    requestDataOBD(PID_CoolantTemp);
    // update counter
    last_temp = millis();
  }

  if (mcp2515.readMessage(&canMsg) == MCP2515::ERROR_OK) {

    if (canMsg.can_id == 0x7eA) { // response from ecu
  
      if (canMsg.data[2] == PID_CoolantTemp) { // Coolant
        
        eng_temp = (9.0*(canMsg.data[3] - 40)/5.0+32.0); // there are formulas for turning the data bytes
          display.setTextSize(2);                        // into actual "numbers". Look on wikipedia page
          display.getTextBounds(String(eng_temp), 0, 0, &xs1, &ys1, &w, &h);
          display.setTextWrap(false);
          display.fillRect(94,0,36,h,SSD1306_BLACK);
          display.setCursor(130-w,0);
          display.print(eng_temp);
          display.display();
        
      }
      if (canMsg.data[2] == PID_RPM) { // ICE RPM
        rpm = (canMsg.data[3]*256 + canMsg.data[4])/4; // same here. Some codes use more than one byte to store
                                                        // the svalue. The real RPM is a conjugate of two
        display.setTextSize(4);                         // bytes, [3] and [4].
        display.setTextColor(SSD1306_WHITE);
        display.getTextBounds(String(rpm), 0, 0, &xs1, &ys1, &w, &h);
        display.fillRect(0, 0, 94, h, SSD1306_BLACK);
        display.setCursor(96-w,0);
        display.cp437(true);
        display.print(rpm);
        display.display();
      }
      
    }

  }
  
}
